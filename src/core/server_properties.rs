use std::collections::HashMap;
use std::path::Path;
use anyhow::{Result, Context};
use tokio::fs;

pub async fn read_server_properties(instance_path: &Path) -> Result<HashMap<String, String>> {
    let props_path = instance_path.join("server.properties");
    if !props_path.exists() {
        return Ok(HashMap::new());
    }

    let content = fs::read_to_string(&props_path).await
        .context("Failed to read server.properties")?;
    
    let mut properties = HashMap::new();
    for line in content.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        if let Some((key, value)) = line.split_once('=') {
            properties.insert(key.trim().to_string(), value.trim().to_string());
        }
    }

    Ok(properties)
}

pub async fn write_server_properties(instance_path: &Path, properties: &HashMap<String, String>) -> Result<()> {
    let props_path = instance_path.join("server.properties");
    
    let mut content = String::new();
    content.push_str("# Minecraft server properties\n");
    content.push_str("# Generated by MC Server Wrapper\n");
    
    // Sort keys for consistent output
    let mut keys: Vec<_> = properties.keys().collect();
    keys.sort();

    for key in keys {
        if let Some(value) = properties.get(key) {
            content.push_str(&format!("{}={}\n", key, value));
        }
    }

    fs::write(&props_path, content).await
        .context("Failed to write server.properties")?;
    
    Ok(())
}
